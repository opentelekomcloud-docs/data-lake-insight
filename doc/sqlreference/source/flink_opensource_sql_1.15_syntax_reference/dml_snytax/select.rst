:original_name: dli_08_15067.html

.. _dli_08_15067:

SELECT
======


SELECT
------

**Syntax**

::

   SELECT [ ALL | DISTINCT ]
     { * | projectItem [, projectItem ]* }
     FROM tableExpression
     [ WHERE booleanExpression ]
     [ GROUP BY { groupItem [, groupItem ]* } ]
     [ HAVING booleanExpression ]

**Description**

SELECT is used to select data from a table.

ALL indicates that all results are returned.

DISTINCT indicates that the duplicated results are removed.

**Precautions**

-  The to-be-queried table must exist. Otherwise, an error is reported.
-  WHERE is used to specify the search condition, which can be the arithmetic operator, relational operator, or logical operator.
-  GROUP BY is used to specify the grouping field, which can be one or more multiple fields.

**Example**

Select the order which contains more than 3 pieces of data.

::

   insert into temp SELECT  * FROM Orders WHERE units > 3;

Insert a group of constant data.

::

   insert into temp select 'Lily', 'male', 'student', 17;

WHERE
-----

**Syntax**

::

   SELECT   { * | projectItem [, projectItem ]* }
     FROM tableExpression
     [ WHERE booleanExpression ]

**Description**

This clause is used to filter the query results using the WHERE clause.

**Precautions**

-  The to-be-queried table must exist.
-  WHERE filters the records that do not meet the requirements.

**Example**

Search orders which contain more than 3 pieces and fewer than 10 pieces of data.

::

   insert into temp SELECT  * FROM Orders
     WHERE units > 3 and units < 10;

HAVING
------

**Function**

This clause is used to search for the query results that meet the search condition.

**Syntax**

::

   SELECT [ ALL | DISTINCT ]   { * | projectItem [, projectItem ]* }
     FROM tableExpression
     [ WHERE booleanExpression ]
     [ GROUP BY { groupItem [, groupItem ]* } ]
     [ HAVING booleanExpression ]

**Description**

Generally, HAVING and GROUP BY are used together. You can use GROUP BY for grouping and then use HAVING for filtering. Arithmetic operations and aggregate functions are supported in the HAVING clause.

**Precautions**

If the filtering condition is subject to the results of GROUP BY, the HAVING clause, rather than the WHERE clause, must be used for search.

**Example**

Group the **student** table according to the **name** field and search for the records in which the maximum score is higher than 95 in the group.

::

   insert into temp SELECT name, max(score) FROM student
     GROUP BY name
     HAVING max(score) >95;

Column-Based GROUP BY
---------------------

**Function**

This clause is used to group a table based on columns.

**Syntax**

::

   SELECT [ ALL | DISTINCT ]   { * | projectItem [, projectItem ]* }
     FROM tableExpression
     [ WHERE booleanExpression ]
     [ GROUP BY { groupItem [, groupItem ]* } ]

**Description**

Column-based GROUP BY can be categorized into single-column GROUP BY and multi-column GROUP BY.

-  Single-column GROUP BY indicates that the GROUP BY clause contains only one column.
-  Multi-column GROUP BY indicates that the GROUP BY clause contains multiple columns. The table will be grouped according to all fields in the GROUP BY clause. The records whose fields are the same are grouped into one group.

**Precautions**

GroupBy generates update results in the stream processing table.

**Example**

Group the **student** table according to the score and name fields and return the grouping results.

::

   insert into temp SELECT name,score, max(score) FROM student
     GROUP BY name,score;

Expression-Based GROUP BY
-------------------------

**Function**

This clause is used to group streams according to expressions.

**Syntax**

::

   SELECT [ ALL | DISTINCT ]   { * | projectItem [, projectItem ]* }
     FROM tableExpression
     [ WHERE booleanExpression ]
     [ GROUP BY { groupItem [, groupItem ]* } ]

**Description**

groupItem can have one or more fields. The fields can be called by string functions, but cannot be called by aggregate functions.

**Precautions**

None

**Example**

Use the substring function to obtain the character string from the name field, group the **student** table according to the obtained character string, and return each sub character string and the number of records.

::

   insert into temp SELECT substring(name,6),count(name) FROM student
     GROUP BY substring(name,6);

Grouping sets, Rollup, Cube
---------------------------

**Function**

-  The GROUP BY GROUPING SETS generates a result set equivalent to that generated by multiple simple GROUP BY UNION ALL statements. Using GROUPING SETS is more efficient.
-  The ROLLUP and CUBE generate multiple groups based on certain rules and then collect statistics by group.
-  The result set generated by CUBE contains all the combinations of values in the selected columns.
-  The result set generated by ROLLUP contains the combinations of a certain layer structure in the selected columns.

**Syntax**

.. code-block::

   SELECT [ ALL | DISTINCT ]   { * | projectItem [, projectItem ]* }
     FROM tableExpression
     [ WHERE booleanExpression ]
     [ GROUP BY groupingItem]

**Description**

Values of **groupingItem** can be **Grouping sets(columnName [, columnName]*)**, **Rollup(columnName [, columnName]*)**, and **Cube(columnName [, columnName]*)**.

**Precautions**

None

**Example**

Return the results generated based on **user** and **product**.

.. code-block::

   INSERT INTO temp SELECT SUM(amount)
   FROM Orders
   GROUP BY GROUPING SETS ((user), (product));

GROUP BY Using HAVING
---------------------

**Function**

This clause filters a table after grouping it using the HAVING clause.

**Syntax**

::

   SELECT [ ALL | DISTINCT ]   { * | projectItem [, projectItem ]* }
     FROM tableExpression
     [ WHERE booleanExpression ]
     [ GROUP BY { groupItem [, groupItem ]* } ]
     [ HAVING booleanExpression ]

**Description**

Generally, HAVING and GROUP BY are used together. You can use GROUP BY for grouping and the HAVING for filtering.

**Precautions**

-  If the filtering condition is subject to the results of GROUP BY, the HAVING clause, rather than the WHERE clause, must be used for search. HAVING and GROUP BY are used together. Use GROUP BY for grouping and the HAVING for filtering.
-  Fields used in HAVING, except for those used for aggregate functions, must exist in GROUP BY.
-  The arithmetic operation and aggregate function are supported by the HAVING clause.

**Example**

Group the **transactions** by **num**, use the HAVING clause to search for the records in which the maximum value derived from multiplying **price** with **amount** is higher than 5000, and return the filtered results.

::

   insert into temp SELECT num, max(price*amount) FROM transactions
     WHERE time > '2016-06-01'
     GROUP BY num
     HAVING max(price*amount)>5000;
